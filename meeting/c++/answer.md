### 指针和引用的概念
指针和引用都能够实现间接的访问某个对象
指针是一个对象，其本身存储的是所指对象的虚拟内存地址，而引用是一个变量的别名.

### 指针和内存的关系
指针所处的地址上存放的值是其指向元素的地址。

### 底层const和顶层const
底层const指的是指针所指的对象是一个const,我们无法修改指针所指向对象的值，但是我们可以修改指针本身的值，即我们可以使指针指向其他对象。
顶层const指的是指针本身是一个const,我们无法修改指针，使其指向其他对象，但是我们可以修改指针所指向的对象的值

观察一个指针+const的组合是顶层const还是底层const, 可以从右向左观察，比如：
const int\*p = &a; 这是一个底层const, const针对int
int \* const p = &a; 这是一个顶层const, const限制的是int\*

### 程序编译过程
gcc -E source.c 预处理阶段，替换宏定义等
gcc -S source.c -o source.asm 编译阶段，将源代码编译成为汇编代码
gcc -c source.asm -o source.o 汇编阶段，将汇编代码翻译为目标文件
ld source.o \*.o 链接阶段，将一大堆的目标文件链接成为可执行文件。

### c和c++区别
c和c++都是编译性、静态类型语言
编译性与解释性相对应，解释性语言通过解释器来翻译成为机器语言来进行执行。例如对于shell、python等解释性语言，如果我们想要某个程序执行多次，那么每一次都需要解释器将其翻译成为对应的机器语言。而对于编译性语言，我们只需要使用编译器一次执行相应的可执行文件，从而执行多次。
编译型语言的优点，不需要提供相应的环境，可以直接运行，如java等解释性语言必须安装jvm虚拟机等。

c++有多种编程范式
既可以象c语言一样面向过程，也就是面向函数编程
也可以像java一样，面向对象编程
为了实现代码的复用，也可以使用泛型编程
还可以采用元编程的编程范式

### 内存模型
c++的内存模型
包括代码段、数据段
为什么要分为代码段和数据段
1. 在链接时，我们需要将多个目标文件的代码段链接在一起成为可执行文件的代码段，我们可以设置代码段为只读，从而防止进程修改程序的指令。
2. 将代码段和数据段分开有助于提高缓存的命中率，现代CPU的缓存一般都被设计成为数据缓存和指令缓存分离
3. 将代码段和数据段分开，那么假设有多个可执行文件都需要printf.o的目标文件，那么这个时候，我们就可以在内存中仅保存一份printf.o的副本，采用动态链接的方法，将printf.o所在的位置填写在可执行文件中，那么可以节省大量的内存。
### 内存中的堆和栈分配
注意到
vector的元数据（记录vector的信息，如size, addr)等保存在栈区，而vector的实际数据保存在堆区。

### 面向对象理解
面向对象的核心思想是数据抽象，继承和动态绑定
数据抽象,也就是封装, 将类的实现和接口分离，通过封装，可以控制对数据的访问，提高代码的可维护性和安全性
继承:允许从现有的类中派生出其他的类，新的类继承了父类的属性和行为，并可以在其基础上进行修改，继承有助于提高代码的可重用性。
多态：多态指的是对象的多种表现形态。通过多态，可以在不同的对象上调用相同的方法，实际执行的操作会依据对象的具体类型而又所不同。多态提高了代码的可维护性和拓展性。
抽象：将对象的共同特征抽象出来，成为类或者接口的过程。

### 析构函数

### 什么是抽象类
抽象类指的是一个类中包含了至少一个纯虚函数，纯虚函数指的是只提供了函数的声明，而没有函数具体的实现的虚函数。
抽象类无法实例化，无法产生具体的对象，其子类必须要实现该虚函数。

### struct和class的区别
struct和class有以下几点区别：
1. 默认的成员访问控制不同
struct中，所有的成员默认为是public, 而class中，所有的成员默认是private
2. struct不支持多态和继承，而class支持多态和继承

### struct内存对齐
对齐主要是由于CPU是按照地址读取的，如果内存是非对齐的，那么CPU读取一个int值，可能必须要访问两次内存，如果地址是对齐的，那么只需要访问一次内存.

### sizeof和strlen的区别
首先，sizeof是一个运算符(就像+, -等)，而strlen是一个函数
其次，sizeof计算的是变量所占空间的大小，而strlen计算的是字符串的长度。
如:
```c
char array[1000];
memset(array, '\0', 1000);
printf("strlen(array) = %d\n", strlen(array));
printf("sizeof(array) = %d\n", sizeof(array));
```
strlen返回的是0, 而sizeof返回的是1000.

### struct和union的共同点和区别
struct和union中都可以持有不同类型的数据.
不同的是struct中所有元素是共存的，而union中元素是互斥的。union的最主要功能是节省内存空间。
union中的所有元素共享同一个内存首地址，union的大小等于union中元素所占内存空间的最大值.

### new/delete和malloc/free的区别
1. new能够自动计算需要分配的内存空间，而malloc需要手动计算需要分配的内存空间
2. new其实包含两个过程，一是使用malloc函数分配空间，而是调用构造函数构造对象；同样，delete也包括两个过程，调用析构函数和释放内存空间.
3. new返回带具体类型的指针，而malloc返回空类型的指针.
### 野指针
野指针（wild pointer），也就是悬挂指针(hang pointer), 指的是无法正常使用的指针。
比如
1. 未初始化的指针
2. 使用delete或者free后的指针(在delete后，应设该指针为NULL）
这些指针所指向的元素是一个随机值，所以无法正常使用，

### static关键字
在c语言中，static主要有两个特点：
1. 无论static修饰的是一个全局变量还是局部变量，static的存续期都会持续到整个程序接受，这是因为static修饰的变量被放置在了全局变量区。另外，static修饰的全局变量和局部变量二者之间没有明显的区别。因此，在一个函数中，我们初始化了一个static局部变量，并且在该函数中，将这个变量值+1，那么下一次调用该函数时，static局部变量的值为初始值+1，再调用一次，值为初始值+2
2. static修饰的变量仅仅在声明它的文件中可见，其他文件不可见，所以无法使用extern关键字引用另外一个文件中的static变量
由于c++是c语言的超集，因此，static在c语言中的特征在c++中也适用，但是static关键字在c++有另外的用途.
1. static修饰类中成员变量
static修饰的类成员变量被称为静态数据成员，静态数据成员必须要在类中声明，在类外定义；另外，静态数据成员属于类本身，不属于任何对象。因为，静态数据成员在所有的对象中是共享的，而非静态数据成员，每一个对象都有一份拷贝.但是静态数据成员对该类的所有对象均可见.
因此，静态数据成员更像是一个全局变量，但是相比于全局变量，它有其独特的优势：
1）静态数据成员没有进入到程序的全局名字空间，因而不存在与程序中其他全局名字冲突的可能性
2) 可以实现信息隐藏，静态数据成员可以是private, 而全局变量不可以
2. static修饰类中成员函数
静态成员函数有以下特点：
1. this指针指向当前对象的地址，而static成员不属于任何一个对象，因此，它没有this指针，因此，它无法访问类中的非静态成员. 也无法调用非静态成员函数，只能够调用静态成员函数.
但是普通成员函数可以访问静态成员，对象也可以访问静态成员，需要遵循public, private, protected等规则.
2. 静态函数可以在类内定义，也可以在类外定义.

### this指针
this指针本身是一个常量指针，其指向的是一个对象，并且必须是这个对象，不能指向其他的对象。它所指对象的内容是可以修改的.
考虑一个类A, 其有一个非const成员函数func(), 那么，其本质上这个func函数的形参是func(A\* const this), 即该指针是一个顶层const指针。
那么对于一个const对象a, 如果让它调用一个非const成员函数，那么这时候this应该是一个const A\* const, 即指针本身指向的内容也不可以更改。由于const是无法隐式转换为非const的，所以这里const对象是无法调用非const成员函数。而const对象调用const成员函数，this指针的类型完全合适，所以const对象可以调用const成员函数。

另外，对于非const对象，由于非const向const的转换是隐式进行的，所以这里相当于从A\* const 自动转换为const A\* const, 因此，非const对象也可以调用const成员函数。并且，如果const成员函数与非const成员函数形参完全相同时（仅仅this指针的类型不同），非const对象首先调用非const成员函数，不需要发生隐式类型转换.

### const关键字
#### const修饰成员函数
const成员对象只能调用const成员函数，不能调用非const成员函数；非const成对象既可以调用非const成员函数，也可以调用const成员函数.

对于const成员数据和非const成员数据，const对象和非const对象都可以使用.

### extern关键字
在c语言中，使用extern关键字是告知编译器，其声明的函数或者变量能够在本模块或者其他模块中使用。

### 面向对象的三大特征
封装, 将类的实现和接口分离，通过封装，可以控制对数据的访问，提高代码的可维护性和安全性
继承:允许从现有的类中派生出其他的类，新的类继承了父类的属性和行为，并可以在其基础上进行修改，继承有助于提高代码的可重用性。
多态：多态指的是对象的多种表现形态。通过多态，可以在不同的对象上调用相同的方法，实际执行的操作会依据对象的具体类型而又所不同。多态提高了代码的可维护性和拓展性。


### 类的访问权限与继承
类的访问权限，对于类的对象而言，只能访问类的公有成员，受保护的成员和私有成员不可见。
继承分为公有继承、保护继承和私有继承
无论是公有继承、保护继承还是私有继承，对于派生类而言，基类的公有成员和保护成员均可访问，而私有成员都是不可访问的。而对于派生类的对象而言，规定则较为复杂。
对于公有继承，派生类的对象可以访问基类的公有成员，无法访问基类的保护成员和私有成员；对于私有继承，基类的所有成员均无法访问；对于保护继承，只是将基类中的public访问变为protected, 这意味着，派生类的对象均无法访问基类的成员.

### 移动拷贝函数和拷贝构造函数对比
#### 拷贝构造函数调用时机
拷贝构造函数调用的三个时机：
1. 函数的形参是一个类的对象
当将一个类的对象传入函数时，会形成一个临时对象，然后这时编译器就调用一个拷贝构造函数将类的对象拷贝到临时对象上，等函数执行完毕后，再调用析构函数析构掉该临时变量。为了避免这种情况，我们传递参数时要传递一个引用，从而避免了拷贝构造过程。
2. 函数的返回值是一个类的对象
比如我们在函数中首先创建了一个类的对象，然后调用return函数将其返回，那么在返回时，首先创建了一个临时对象，然后调用拷贝构造函数拷贝到临时对象上，等函数执行到最后，首先析构掉该临时对象，在析构掉创建的对象.
3. 对象需要另外一个对象进行初始化。
如 Example A(100);
   Example B = A;
在这个过程中，B对象是调用了拷贝构造函数将对象A的值拷贝赋值给了B. 这和下面的例子不同：
Example A(100);
Example B;
B = A;
在这个过程中，首先B使用了缺省的默认构造函数，然后调用了一个赋值构造函数将A的值赋值给了B.
note:要想在程序中验证这一结论，要关闭g++的RVO(return value optimation)优化，即g++ -fno-elide-constructors.

#### 浅拷贝和深拷贝
1. 默认的拷贝构造函数
如果我们不指定拷贝构造函数，那么编译器将会为我们自动生成一个默认的拷贝构造函数
2. 浅拷贝
但是默认的拷贝构造函数进行的只是浅拷贝，即在对象复制时，只是对对象中的数据成员进行简单的赋值。但是一旦对象中存在动态成员，那么浅拷贝就会失效。

假设对象中有个指针，需要动态分配内存，那么这时候，浅拷贝在对对象进行拷贝的过程中，会让两个对象中的指针指向同一块物理内存，那么当进行对象析构时，两个对象的析构函数将两次析构同一块内存，因而会发生错误.（见./copyconstructor/example3.cpp)

这里的解决办法是让两个对象的动态成员指向两块不同的物理内存，但是这两个物理内存中的值是相同的.这也就是深拷贝存在的意义所在. （见./copyconstructor/example4.cpp)

3. 拷贝构造函数的参数是一个引用，而不是值传递
值传递的话会出现无限递归构造，如果拷贝构造函数的参数是一个对象，那么就会出现拷贝构造函数的调用，周而复始，无限递归。

####移动拷贝构造函数
有时候我们会遇到这样一种场景，我们利用对象a初始化对象b, 然后对象a就不使用了，那么这种情况下，我们为什么不直接使用a的内存空间，这样就避免了新的空间分配，大大降低了构造的而成本。

这里移动拷贝构造函数应用的就是浅拷贝，即让两个对象的指针指向同一块物理内存，但是在完成对于指针的拷贝后，将原有对象的指针指向null.(见example5.cpp);

那我们怎样使函数在调用的过程中，使用移动拷贝构造函数而不是拷贝构造函数呢？方法是使用右值引用。如果一个表达式不能取地址，那么我们称这个表达式为右值。如非引用返回的临时变量值，一些运算表达式，如1+2产生的临时变量；不能与对象产生联系的字面量值，如"c", "123"等；这些值都不能被取地址。这些值都是右值。

这里有一个场景，vector<Mystring> vec; vec.push\_back(Mystring("hello"));这里Mystring("hello")产生了一个临时对象，这是一个右值，如果临时对象通过一个接受右值的函数传递给另外一个函数时，就会变为左值。因此，这里会调用拷贝构造函数（拷贝构造函数的参数是一个左值引用），产生了一个命名对象，即实参。我们可以看到，这里调用的是拷贝构造函数。实际上发生了两次构造，一次，Mystring("Hello")调用了默认的构造函数，一次调用了拷贝构造函数。并且这个临时对象被拷贝构造之后成便失去了作用，因此，这里调用一个移动拷贝构造函数更加何时。

所以，这里我们需要让这个临时对象通过移动拷贝构造函数来构造出一个实参对象，而不是拷贝构造函数。考虑到临时对象是一个右值，所以，这里我们可以设置移动拷贝构造函数的参数是一个右值引用来实现。

这样，我们通过临时对象构造的实参对象将使用移动拷贝构造函数而不是拷贝构造函数来实现.
另外，我们可以使用std::move将一个左值变为一个右值. 所以即使一个函数的参数不是一个临时对象，我们也可以将其变为右值引用，从而使用移动拷贝构造函数.
见copyconstructor/example6.cpp

### 空类有哪些函数？空类的大小？
空类的大小为1, 空类中包含了默认的构造函数，默认的拷贝构造函数，默认的赋值函数，默认的析构函数。
空类也可以被实例化，空类被实例化后，也会创建一个对象;可以看到，empty/Empty.cpp中，两个空类的对象的地址之间差距为1，这一方面说明，空类的大小为1，另外一方面说明，实例化的过程就是在内存中分配一块内存. 且这两个对象位于堆栈上.

另外，类的大小与以下几个因素有关
1. 为类的非静态数据成员的大小之和
2. 有编译器额外加入的成员变量的大小，用来支持语言的某些特征（如：指向虚函数的指针）
3. 为了优化存储效率，进行的对齐调整
4. 与函数的多少无关（函数位于代码段）

### 什么是动态多态，什么是静态多态？
多态指的是多种形态，即一个接口，多种方法.
静态多态是指在编译期间的多态，编译器根据实参的类型（可能会发生隐式类型转换），决定调用哪一个函数，如果有对应的函数，就调用该函数，否则返回一个错误。
静态多态包含两种类型：
1. 普通函数或者类中的成员函数的重载（如构造函数）
2. 函数模板的使用
动态多态指的是在运行期间的多态，在程序的执行期间判断所引用对象的实际类型，根据其实际类型决定调用哪一个函数
静态类型：即声明时的类型
动态类型：即指针或引用指向的类型.
动态绑定：绑定的是动态类型，所对应的函数和属性属于对象的动态类型，在运行时确定
静态绑定: 绑定的时静态类型，所对应的函数和属性属于对象的静态类型，在编译时确定

只有虚函数使用动态绑定，其余均使用静态绑定.

### 虚函数实现动态多态的原理，虚函数和纯虚函数的区别
纯虚函数指的是在基类中只能声明，没有实现的以virtual关键字开头的虚函数。一个包含虚函数的类被称为抽象类，抽象类不能实例化，其子类必须实现基类的虚函数，其子类可以实例化。

#### 虚函数表与虚函数表指针
如果一个类中定义了一个虚函数，那么在调用构造函数的过程中编译器就会创建一个虚函数表，并且在对象中维护一个虚函数表指针, 指向创建好的虚函数表。我们可以看到，如果一个空类中添加了一个或者多个虚函数，那么这个空类的大小将会变为8，实际上这个8就代表这个虚函数表指针的大小。

这个虚函数表是一个函数指针的数组，包含了所有虚函数的地址。当一个对象要调用虚函数时，根据虚函数表指针找到对应的虚函数，从而完成虚函数的调用。

另外，需要注意的一点是：虚函数表是针对类的，一个类的所有对象的虚函数表都是一样的.
#### 单继承类
如果一个子类只继承了一个父类，那么如果该子类没有重写父类中的虚函数，那么在子类的虚函数表中保存的是父类的虚函数的地址。否则，保存子函数的虚函数的地址。这样，当一个子类的对象调用虚函数时，如果子类对象就会根据虚函数表中的地址调用相应的函数.

#### 多继承类
指的是一个子类继承了多个父类，那么这时候该子类就包含多个函数表指针，至于虚函数表中的内容及调用方式，与单继承类相同。


### 继承时，父类的析构函数能否时虚函数？构造函数能否是虚函数？为什么？
构造函数不能是虚函数，因为在执行构造函数前对象尚未完成创建，虚函数表还不存在。
析构函数主要用于销毁对象时释放资源，析构函数可以被声明为虚函数。在继承中，基类的析构函数一般被设置为虚函数。
如果不设置为虚函数的话，那么考虑以下Base \* base = new Derived; 在整个程序结束之后，由于Base的析构函数没有被设置为虚函数，那么这个时候base对象将调用基类的析构函数释放内存，但是我们是使用派生类来创建的对象，因此，这里会发生内存泄漏。所以，我们这里要将基类的析构函数设置为虚函数，这样，在析构时，才能调用正确的析构函数.

### 菱形继承与虚继承
菱形继承的问题在于类需要维护两份GrandParent基类的数据，分别存在于father和mother中，浪费内存空间，且访问GrandParent基类数据必须要使用child.father::data这种方式。
为了解决菱形继承的问题，C++引入了虚继承机制，也就是虚基类机制，这里的虚基类指的是GrandParent类。方法是在father和mother继承时使用virtual关键字来继承，这样的话在最后的派生类中只需要维护一份GrandParent基类的数据。且访问GrandParent的数据也不需要域作用符。

详见virtualInheritance/example1.cpp及example2.cpp

### 四种类型转换
隐式类型转换是由编译器自动进行的，而显示类型转换需要明确指出。
c++支持c语言风格的强制转换，但是c风格的强制类型转换可能会带来一些隐患，让问题难以发现，因此，c++提供了一组类型转换函数，可以在不同场景下强制转换类型。
#### static\_cast
1. static\_cast主要用于基本数据类型之间的转换，如将int转换为double等，
2. static\_cast没有运行时类型检查来保证转换的安全性，需要程序员来判断转换是否安全.
如int x = -1;
uint y = static\_cast<uint>(x);是错误的转换方式.
3. static\_cast还可以用来基类和派生类指针或者引用之间的转换，但是它只能将一个派生类转换为一个基类，而无法将一个基类转换为一个派生类。将一个基类通过static\_cast转换为一个派生类是不安全的.

#### dynamic\_cast
1. dynamic\_cast主要用来实现基类和派生类指针或者引用的类型转换。将一个派生类的指针或者引用转换为基类的指针或引用，这一方面，dynamic\_cast和static\_cast效果是相同的. 而将基类的指针或者引用转换为派生类的指针或者引用，dynamic\_cast相对于static\_cast更加安全, 因为它具有类型检查的特点.

在进行下行转换时，及将一个基类的指针或者引用转换为一个派生类的指针或者引用时，如果基类中有虚函数，那么dynamic\_cast就会将这个指针变为空指针，否则会编译出错，因为这个转换的过程是由虚函数表完成的，如果没有虚函数表，那么dynamic\_cast就会出错. 见./cast/dynamic\_cast.cpp

3. const\_cast
通过const\_cast, 我们能够改变一个表达式的const属性，比如我们有一个底层const指针，这个指针指向变量x的值，由于这个指针是一个底层const指针，所以我们无法通过该指针修改变量x的值，但是我们又期望修改x的值，这时我们可以通过const\_cast来实现，具体步骤见./cast/const\_cast.cpp
4. reinterpret\_cast
这个cast能够将一个指针转换为一个整数，也可以将一个整数转换一个指针，这个转换由于可以转换完全不相关的类型，因此，不推荐使用。

###四种智能指针及其底层实现
智能指针就是帮我们C++程序员管理动态分配的内存，它会帮助我们自动释放new出来的内存，从而避免内存泄漏.
实际上，为了支持智能指针这种c++语言特性，编译器额外增加了一些成员变量，这些成员变量是指向智能指针的地址，编译器自动帮我们在对象的析构函数中通过这个地址释放掉动态分配的内存. 我们可以在./empty/Empty.cpp中看到编译器增加的成员变量的大小，为一个auto\_ptr和unique\_ptr增加8个字节，为一个shared\_ptr增加16个字节.
#### auto\_ptr
auto\_ptr的缺点
1. auto\_ptr是基于排他所有权模式，两个指针不能指向同一个对象。当发生复制语句，比如ptr0 = ptr1时，ptr0所指向的对象首先会调用析构函数，释放掉其占据的内存空间，随后ptr0指向ptr1所指向的对象，然后将ptr1指向null.整个过程就像是指针的浅拷贝。
2. auto\_ptr不能成为STL容器中的元素，因为STL容器中的元素要求是可复制和可赋值的，而auto\_ptr不满足其中的要求. 因为auto\_ptr要求其复制构造函数具有移动拷贝构造函数的特点，因此，因此，auto\_ptr中没有提供const类型的拷贝构造函数.
而vector.push\_back有两种类型的参数，一种是const T& value, 一种是T&& value,也就是说有两种，一是const类型的引用，而是右值引用，因为右值引用是直到c++11中才出现的，所以在auto\_ptr的时代，只有const T&这一个种类可以选择，而在传参的过程中，将auto\_ptr隐式转换为const类型，而auto\_ptr没有提供const类型的拷贝构造函数，因此，auto\_ptr不能成为容器中的元素.
3. auto\_ptr不支持指向一个对象数组.
#### unique\_ptr
unique\_ptr和auto\_ptr一样，也是一种基于排他所有权模式的智能指针，二者区别在于，unique\_ptr弥补了auto\_ptr的部分缺陷
1. unique\_ptr能够成为容器中的元素，主要原因是由于右值引用的使用，由于c++11之后，支持右值引用，所以一旦我们提供了unique\_ptr的移动拷贝函数和vector.push\_back的右值引用版本，那么我们就可以在容器中使用unique\_ptr.
2. unique\_ptr也支持指向一个对象数组.
除此之外，unique\_ptr还有以下特点
1. 不支持左值复制构造，但支持右值复制构造
#### share\_ptr
unique\_ptr的主要缺陷在于如果需要多个智能指针指向同一块物理内存怎么办？share\_ptr就是用来解决这个问题的，其采取的措施是，对于每一个对象，维护一个引用计数，当一个智能指针指向该对象时，该引用计数+1，当一个智能指针释放其所指对象时，该引用计数-1，如果该引用计数为0，那么调用该对象的析构函数。

但是shared\_ptr的使用可能会引发循环引用的问题，如有两个类，每个类中都包含着指向对方类对象的一个指针，那么就有可能会引发循环引用问题。
可以使用weak\_ptr来解决循环引用问题.
#### weak\_ptr
weak\_ptr是为了配合shared\_ptr而引入的智能指针，它有以下几个特点：
1. 它只能由一个shared\_ptr或者weak\_ptr来构造
2. 它的构造和析构都不会引发引用计数的增加或者减少
3. 它没有重载\*和->，但可以通过.lock函数来获取一个shared\_ptr对象

#### 关于智能指针使用的几个陷阱
1. 尽量不要使用多个unique\_ptr指向同一个对象
2. release函数不会释放内存，需要保存返回值，使用delete函数释放
3. 禁止delete智能指针通过get函数的返回值
当使用delete函数释放掉智能指针指向的内存值，那么该指针就会变成一个野指针，其指向的内容毫无意义。
4. 不要使用get函数返回的智能指针初始化另一个智能指针。
