### OSI七层模型
1. 应用层：提供应用程序之间通信, 定义的协议有HTTP, https等
2. 表示层: 处理数据格式, 进行数据加密等
3. 会话层: 建立、维护和管理会话
4. 传输层: 建立端对端联系
5. 网络层:
6. 数据链路层:
7. 物理层

### TCP/IP四层模型
应用层、表示层和会话层处理具体网络应用（ftp, http, telnet)的所有细节，对通信细节了解很少
底下四层处理通信细节，对具体网络应用了解不多：发送数据，等待确认，给无序到达的数据包排序，计算并验证校验和。
上面三层通常构成了所谓的应用进程，而后四层则通常作为操作系统的内核的一部分提供，这保证了操作系统的隔离性。因此，我们通常在第四层和第五层之间构建socket api.

应用层：负责处理应用程序之间的通信
传输层：负责处理端到端的连接，主要包括两个协议，tcp和udp.TCP提供了面向连接的可靠数据传输服务，而UPD是非连接的不可靠的数据传输服务。
网络层：负责处理网络中的数据传输。将tcp或者udp段加上IP头部形成ip数据包，从而可以实现将数据从源主机发送到目的主机。
数据链路层：将ip数据包添加上MAC地址，帧检验序列，成为以太网帧，再通过网卡将以太网帧发送出去.

一个以太网帧通常包含两个校验和，帧检验序列(FCS)和IP首部校验和。
帧检验序列负责检验整个以太网帧在物理层传输是否出现错误，物理层在传输的过程中容易受到噪音和干扰的影响，因此，出现错误的可能性就越大，那么我们就可以通过帧检验序列检查数据是否发生了位错误，字节错误，帧破坏等
IP首部校验和检验ip首部是否发生了错误，ip首部包含了重要的控制信息，如源地址，目标地址，协议类型等，ip首部错误的话，可能会导致ip数据包发送到了错误的目的主机，因此，需要使用IP首部校验和来检验ip首部是否发生了错误。

### TCP/UDP区别
1.无边界
无边界意味着输同一批数据，传输端和接收端可以使用任意次数的read和write来接受和发送数据,传输基于bytestream, 即字节序，意味着可能会出现数据边界问题.
2. 面向连接
首先，要传输数据，必须要建立端与端之间的连接，然后再传递数据
3. 可靠性
重传机制，序列（排序），网际校验和
4. 全双工与半双工
TCP可以实现全双工，即在发送数据的同时，也可以接受数据
UDP只能实现半双工，不过在UDP中也有ack报文的确认.
5. 流量机制(即滑动窗口机制）
在传输的过程中，接收到的ACK确认TCP段中通常都包含了window size, 因此，在发送的时候，不能发送超过window size大小的数据包。

### 滑动窗口大小的选择
在发送的过程中，发送端接收到了接收端的接受窗口大小，如果发送端发送窗口大小过大，那么就会造成接收端应用层阻塞，知道应用程序读到数据，使接收端的滑动窗口大小变大.才会接受相应的数据包
另外，发送端发送窗口大小过大，一次发送的数据包过多，超过了路由器的缓存区大小，这时在路由器层面也会丢包，影响传输效率
路由器发送窗口大小过小，一次传输的数据包数目也很小，通过也会影响传输效率

发送端发送窗口的大小取决于两个元素，一是接收端滑动窗口的大小，而是网络所能承受的能力，也就是路由器短时间内能够接收到了的数据包数量。
发送端发送窗口的大小，我们是可以确定的，网络所能承受的能力是一个不断变化的数值
TCP采用了两个阶段来确定网络承受能力，即拥塞窗口的大小
1. 慢启动阶段
拥塞窗口大小从1开始按指数增长，直到达到一个阈值(65536)
2. 拥塞避免阶段
拥塞窗口大小开始线性增长，若发生拥塞，则将此值减半
发送端发送窗口的大小取拥塞窗口大小与接收端接受窗口大小的最小值.
### TCP状态中的TIME\_WAIT
1. 可靠地实现TCP双全工的终止
考虑到TCP的四次挥手,主动关闭的一端首先发送一个FIN数据包给目的主机，目的主机接收之后，首先返回一个ACK数据包，然后read函数返回0，调用close函数，发送一个FIN数据包, 然后主动关闭的一端接收到了FIN数据包，返回一个ACK数据包。如果说目的主机一直没有接收到最后一个ACK数据包，那么它就有可能重新发送一个FIN数据包. 这时，如果处于CLOSED状态, 就无法接收到这样一个FIN数据包，所以，这时，我们需要处于一个CLOSED\_WAIT状态，从而保证在发送完最后一个ACK数据包时，能够防止ACK数据包丢失，从而能够再次接收到FIN数据包，再次重新发送ACKN数据包.
2. 防止一些老的重复字节在新的连接中被错误使用
如果说我们关闭了连接之后，再次建立了一个相同端口的TCP连接，那么，如果这时，上个连接的某些数据包还在网络中传输，那么这些旧的数据包可能会被认为发送给这个新的连接(相同IP地址，相同端口)，因而可能会发生某些错误。而如果设置了TIME\_WAIT状态，那么这些旧的数据包就会在网络中消逝，不会干扰到新的连接.

### TCP长连接和短连接以及优缺点
TCP短连接：连接->传输数据->断开连接
TCP长连接：连接->传输数据->保持连接->传输数据->保持连接->..->断开
短连接即连接完传输数据后，使用close函数，断开连接
长连接的缺点，长时间没有数据传输而造成的资源浪费和数据传输延迟，短连接的缺点，频繁的建立和断开连接而造成的通信开销和网络拥堵
因此，长连接多用于操作频繁，点对点的通讯，而短连接则适用于一次性传输数据或者数据传输较少的场景。

### TCP的快重传
当服务器端像客户端传输了一个seqno为2的报文段丢失，这时客户端没有接收到seqno为2的报文段，那么这时候客户端返回的ackno值一直为2，表示没有受到seqno为2的报文段，如果服务器端连续收到了3个ackno为2的报文段，那么这时候就认为seqno为2的报文段丢失，就会立即重传seqno为2的报文段，而不需要等待超时丢失重传

### TCP如何解决粘包和拆包问题
粘包问题其实指的就是数据边界问题，即一次recv了多次send的数据，或者一次recv没有接受完一次send的数据, 从而无法解析的问题。
#### TCP出现数据边界的原因
1. 套接字缓冲区太小
一个应用程序发送的消息的大小大于tcp发送端缓冲区的大小，所以该数据包必须要分隔开才能发送.
2. TCP中的MSS
一旦应用程序产生的消息大于MSS，就必须要对应用产生的消息进行分割
3. IP中的MTU
一旦数据段的长度大于MTU，就必须要将Tcp报文段进行分组
###解决方法
1. 发送定长包
2. 包尾加上/r/n(ftp)
3. 包头加上包体长度
4. 更加复杂的应用层协议

对于方案1
由于read或者write一次
