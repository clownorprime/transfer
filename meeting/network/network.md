### OSI七层模型
1. 应用层：提供应用程序之间通信, 定义的协议有HTTP, https等
2. 表示层: 处理数据格式, 进行数据加密等
3. 会话层: 建立、维护和管理会话
4. 传输层: 建立端对端联系
5. 网络层:
6. 数据链路层:
7. 物理层

### TCP/IP四层模型
应用层、表示层和会话层处理具体网络应用（ftp, http, telnet)的所有细节，对通信细节了解很少
底下四层处理通信细节，对具体网络应用了解不多：发送数据，等待确认，给无序到达的数据包排序，计算并验证校验和。
上面三层通常构成了所谓的应用进程，而后四层则通常作为操作系统的内核的一部分提供，这保证了操作系统的隔离性。因此，我们通常在第四层和第五层之间构建socket api.

应用层：负责处理应用程序之间的通信
传输层：负责处理端到端的连接，主要包括两个协议，tcp和udp.TCP提供了面向连接的可靠数据传输服务，而UPD是非连接的不可靠的数据传输服务。
网络层：负责处理网络中的数据传输。将tcp或者udp段加上IP头部形成ip数据包，从而可以实现将数据从源主机发送到目的主机。
数据链路层：将ip数据包添加上MAC地址，帧检验序列，成为以太网帧，再通过网卡将以太网帧发送出去.

一个以太网帧通常包含两个校验和，帧检验序列(FCS)和IP首部校验和。
帧检验序列负责检验整个以太网帧在物理层传输是否出现错误，物理层在传输的过程中容易受到噪音和干扰的影响，因此，出现错误的可能性就越大，那么我们就可以通过帧检验序列检查数据是否发生了位错误，字节错误，帧破坏等
IP首部校验和检验ip首部是否发生了错误，ip首部包含了重要的控制信息，如源地址，目标地址，协议类型等，ip首部错误的话，可能会导致ip数据包发送到了错误的目的主机，因此，需要使用IP首部校验和来检验ip首部是否发生了错误。

### TCP/UDP区别
1.无边界
无边界意味着输同一批数据，传输端和接收端可以使用任意次数的read和write来接受和发送数据,传输基于bytestream, 即字节序，意味着可能会出现数据边界问题.
2. 面向连接
首先，要传输数据，必须要建立端与端之间的连接，然后再传递数据
3. 可靠性
重传机制，序列（排序），网际校验和
4. 全双工与半双工
TCP可以实现全双工，即在发送数据的同时，也可以接受数据
UDP只能实现半双工，不过在UDP中也有ack报文的确认.
5. 流量机制(即滑动窗口机制）
在传输的过程中，接收到的ACK确认TCP段中通常都包含了window size, 因此，在发送的时候，不能发送超过window size大小的数据包。

### 滑动窗口大小的选择
在发送的过程中，发送端接收到了接收端的接受窗口大小，如果发送端发送窗口大小过大，那么就会造成接收端应用层阻塞，知道应用程序读到数据，使接收端的滑动窗口大小变大.才会接受相应的数据包
另外，发送端发送窗口大小过大，一次发送的数据包过多，超过了路由器的缓存区大小，这时在路由器层面也会丢包，影响传输效率
路由器发送窗口大小过小，一次传输的数据包数目也很小，通过也会影响传输效率

发送端发送窗口的大小取决于两个元素，一是接收端滑动窗口的大小，而是网络所能承受的能力，也就是路由器短时间内能够接收到了的数据包数量。
发送端发送窗口的大小，我们是可以确定的，网络所能承受的能力是一个不断变化的数值
TCP采用了两个阶段来确定网络承受能力，即拥塞窗口的大小
1. 慢启动阶段
拥塞窗口大小从1开始按指数增长，直到达到一个阈值(65536)
2. 拥塞避免阶段
拥塞窗口大小开始线性增长，若发生拥塞，则将此值减半
发送端发送窗口的大小取拥塞窗口大小与接收端接受窗口大小的最小值.
### TCP状态中的TIME\_WAIT
1. 可靠地实现TCP双全工的终止
考虑到TCP的四次挥手,主动关闭的一端首先发送一个FIN数据包给目的主机，目的主机接收之后，首先返回一个ACK数据包，然后read函数返回0，调用close函数，发送一个FIN数据包, 然后主动关闭的一端接收到了FIN数据包，返回一个ACK数据包。如果说目的主机一直没有接收到最后一个ACK数据包，那么它就有可能重新发送一个FIN数据包. 这时，如果处于CLOSED状态, 就无法接收到这样一个FIN数据包，所以，这时，我们需要处于一个CLOSED\_WAIT状态，从而保证在发送完最后一个ACK数据包时，能够防止ACK数据包丢失，从而能够再次接收到FIN数据包，再次重新发送ACKN数据包.
2. 防止一些老的重复字节在新的连接中被错误使用
如果说我们关闭了连接之后，再次建立了一个相同端口的TCP连接，那么，如果这时，上个连接的某些数据包还在网络中传输，那么这些旧的数据包可能会被认为发送给这个新的连接(相同IP地址，相同端口)，因而可能会发生某些错误。而如果设置了TIME\_WAIT状态，那么这些旧的数据包就会在网络中消逝，不会干扰到新的连接.

### TCP长连接和短连接以及优缺点
TCP短连接：连接->传输数据->断开连接
TCP长连接：连接->传输数据->保持连接->传输数据->保持连接->..->断开
短连接即连接完传输数据后，使用close函数，断开连接
长连接的缺点，长时间没有数据传输而造成的资源浪费和数据传输延迟，短连接的缺点，频繁的建立和断开连接而造成的通信开销和网络拥堵
因此，长连接多用于操作频繁，点对点的通讯，而短连接则适用于一次性传输数据或者数据传输较少的场景。

### TCP的快重传
当服务器端像客户端传输了一个seqno为2的报文段丢失，这时客户端没有接收到seqno为2的报文段，那么这时候客户端返回的ackno值一直为2，表示没有受到seqno为2的报文段，如果服务器端连续收到了3个ackno为2的报文段，那么这时候就认为seqno为2的报文段丢失，就会立即重传seqno为2的报文段，而不需要等待超时丢失重传

### TCP如何解决粘包和拆包问题
粘包问题其实指的就是数据边界问题，即一次recv了多次send的数据，或者一次recv没有接受完一次send的数据, 从而无法解析的问题。
#### TCP出现数据边界的原因
1. 套接字缓冲区太小
一个应用程序发送的消息的大小大于tcp发送端缓冲区的大小，所以该数据包必须要分隔开才能发送.
2. TCP中的MSS
一旦应用程序产生的消息大于MSS，就必须要对应用产生的消息进行分割
3. IP中的MTU
一旦数据段的长度大于MTU，就必须要将Tcp报文段进行分组
###解决方法
1. 发送定长包
2. 包尾加上/r/n(ftp)
3. 包头加上包体长度
4. 更加复杂的应用层协议

###为什么要使用readn和writen来替代read或者write函数
拿readn和read函数来对比
若以阻塞方式读取，二者没有差别，若套接字缓冲区内没有数据，那么就阻塞，直到套接字缓冲区有数据
真正有区别的时非阻塞方式读取
当以非阻塞方式读取时，若read函数返回0，那么这时error如果为EINTR，那么这时我们不认为它是一个错误，可以看到，在readn函数中，我们继续调用read函数，直到读取到一定长度的数据。

### 僵尸进程与SIGCHLD信号
子进程调用exit函数终止时，子进程退出，内核发送一个SIGCHLD信号给父进程，如果父进程没有处理该信号，这时该子进程就时一个僵死进程, 我们应该使用信号处理函数处理该信号，在信号处理函数中使用waitpid函数，退出子进程

### SIGPIPE信号与RST报文段
当服务器端关闭之后，客户端再次调用write函数向服务器端发送数据，这时由于服务器端与客户端连接的子进程已经关闭，所以会发送一个rst报文段给客户端，客户端应该对该rst报文端进行处理，如果这时客户端再次调用write函数向套接字中写数据，就会引发一个SIGPIPE信号，这就像是向一个没有读操作或者意外终止的管道中写数据，而引发的SIGPIPE.
发送RST报文段的另外一种情况是，客户端或者服务器端的任一方发生异常（如程序崩溃），这时发生异常的一方就会发送一个rst报文段给对方，提醒其关闭tcp连接.发送RST报文段的另外一种情况是，客户端或者服务器端的任一方发生异常（如程序崩溃），这时发生异常的一方就会发送一个rst报文段给对方，提醒其关闭tcp连接.发送RST报文段的另外一种情况是，客户端或者服务器端的任一方发生异常（如程序崩溃），这时发生异常的一方就会发送一个rst报文段给对方，提醒其关闭tcp连接.
发送RST报文段的另外一种情况是，客户端或者服务器端的任一方发生异常（如程序崩溃），这时发生异常的一方就会发送一个rst报文段给对方，提醒其关闭tcp连接.发送RST报文段的另外一种情况是，客户端或者服务器端的任一方发生异常（如程序崩溃），这时发生异常的一方就会发送一个rst报文段给对方，提醒其关闭tcp连接.
发送RST报文段的另外一种情况是，客户端或者服务器端的任一方发生异常（如程序崩溃），这时发生异常的一方就会发送一个rst报文段给对方，提醒其关闭tcp连接.

### IP地址以及子网掩码
每一个IP地址最前面都有一个类别位，0代表A类，10代表B类，110代表c类，1110代表D类，1111代表e类，
A类地址8位网络号+24位主机号
B类地址16位网络号+16位主机号
C类地址24位网络号+8位主机号
类别位位于网络号中
使用子网掩码能够确定两个IP地址是否属于同一个网段

### HTTP状态码
HTTP状态码是服务器端在处理客户端请求时返回的3位数字代码，状态码帮助客户端和服务器端之间进行更有效地沟通.一些常见的代码以及含义：
1xx (信息性状态码）表示请求已被接受，继续处理
100（continue): 服务器已经收到了请求的初始部分，客户端应该继续发送剩余部分
101: 服务器要求客户端请求协议
2xx (成功状态码）：表示请求已经成功被服务器接收、理解和处理
200 OK : 请求成功，返回正常结果
201 Created: 请求成功，并且在服务器上创建了新的资源
204 No content: 请求成功，但响应报文不包含实体主体部分
3xx（重定向状态码）表示客户端需要采取进一步行动来完成操作
301:请求的资源已经被永久地转移到其他位置
302：请求资源暂时被转移到其他位置
304：客户端可以使用缓存的版本，因为资源暂时未被修改
4xx(客户端错误状态码）表示客户端请求有错误或者无法完成该请求
400: 请求无效，服务器无法理解
401： 请求需要用户身份验证
404：请求的资源未被找到

5xx(服务器错误状态码）表示服务器在处理请求时遇到错误
500：服务器遇到了意外地错误，无法完成请求
503：服务器无法处理当前请求，可能由于过载或者维护

### Nagle算法
Nagle算法的应用领域主要是在TCP协议上，适用于发送大量小数据块的场景上，通过合并小数据块，Nagle算法可以减少网络传输的次数，从而提高传输效率
算法流程：
1. 当应用程序发送一个小数据块时，将该数据块缓存起来
2. 如果此时网络上还有未确认的数据包，则继续等待，直到受到确认或者超时
3. 当确认收到或者超时后，将缓存的数据块与新的数据块合并，形成一个大的数据块，
4. 将合并后的数据块传输出去
Nagle算法的缺点是有延迟，为了关闭nagle算法，可以使用setsocketopt函数，设置TCP\_NODELAY.

### ARP及通信问题
####为什么不直接采用IP地址进行通信
有些局域网使用的是DHCP，也就是说该局域网上每一台主机的IP地址是动态变化的，如果这个主机刚刚是这个ip,突然断网后，可能回引发ip地址的重新分配，这时数据可能就会发送给另外一台主机。

####为什么不直接使用mac地址进行通信
因为mac地址标识着唯一的显卡，显卡是由不同的硬件厂家进行生产的，因而mac地址是非标的，因此，要想直接使用mac地址进行通信，就必须要进行非常复杂的硬件地址转换机制, 由用户主机来完成几乎是不可能的事情。

#### ARP地址解析协议的过程
以太网帧通常需要包含目的主机的mac地址，而通常情况下我们只知道目的主机的IP地址，这个时候我们就需要ARP协议来完成IP地址与mac地址的转换.
ARP地址解析协议就是给定一个IP地址，找到其相应的mac地址
如果说要寻找的主机与源主机在同一局域网内（子网掩码），那么这时，如果说在本机的ARP高速缓存中有该ip地址的mac地址，那么就直接返回，否则，该主机在该局域网内广播一个ARP请求分组，那么该局域网上的所有主机受到该ARP请求分组之后，如果该ARP请求分组上的ip地址与本机ip地址一致，就返回本机的mac地址，否则丢弃该arp请求分组.在得到mac地址和ip地址的对应关系后，源主机就会在其ARP缓存中保存一个从mac地址到ip地址的映射。方便下一次再与该目的主机通信.

如果目的主机不在同一个局域网内，那么就会把该arp请求发送给默认网关（路由器），由路由器寻找距离目标主机最近的下一个路由器，然后将arp请求发送给该路由器，直到路由器与目的主机位于同一局域网中，再由该路由器转发该arp请求，从而得到对应的mac地址.
### 数据包与路由器
路由器中保存的路由表, 保存了目的ip地址所在局域网与下一跳路由器的Ip地址的映射关系.
数据包在经过路由器时，其源IP地址和目的IP地址的值不会变化，而源mac地址和目的mac地址一直在发生变化，源mac地址被设置成当前路由器的mac地址，而目的mac地址被设置成下一个路由器的mac地址.

###DNS原理
可以通过查看/etc/resolv命令来查看本地DNS服务器IP地址
当用户在浏览器上输入了url,浏览器将向本地DNS服务器发送一个DNS查询请求，以查询该域名的IP地址

如果本地DNS服务器上具有该域名的IP地址的缓存副本，就将该IP地址返回给浏览器，否则，本地DNS服务器将向根DNS服务器上发送一个DNS查询请求
根DNS服务器(.)将返回一个指向顶级域名服务器(.net,.com等）的IP地址，本地DNS服务器将向顶级域名服务器发送一个DNS查询请求，并得到一个指向次级域名服务器的IP地址，整个过程循环往复，直到找到域名对应的IP地址。
