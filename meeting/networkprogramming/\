### UDP与UNIX域协议
#### UDP
udp提供的是面向非连接的不可靠的数据传输服务。
其不可靠主要体现在：
1. 报文段有可能失序或者重复或者丢失
    没有确认报文段的传输，没有超时重传机制
2. 数据可能会面临截断
    假设套接字接受缓冲区大小为3， 发送了四个字节的数据，那么报文段就会被截断, 只接受前三个字节的数据

#### 接受发送数据的函数
对于TCP，一般使用write或者send来发送数据，使用recv或者read函数来接收数据，read/write和recv/send的区别在于，后二者是前二者的超集，能够提供更多的选项
对于UDP, 一般使用recvfrom接受数据，使用sendto发送数据
recvfrom函数返回0，并不代表连接关闭，因为UDP是非连接的，所以UDP的服务端代码需要一直调用recvfrom函数，即使其值返回为0

#### ICMP异步错误与UDP connect
由于sendto函数仅仅把sendbuf中的数据传输给套接字缓冲区内，然后就返回，所以即使服务器端程序尚未打开，那么此时sendto函数也会返回，这时客户端程序将会阻塞于recvfrom函数，而send函数却正常返回，这是一种ICMP异步错误.

tcp/ip规定，ICMP异步错误不能传递给未连接的套接字，所以这时候我们应该使ICMP错误能够被recvfrom函数识别，那么这时我们就应该使用UDP connect函数

#### UDP外出接口的确定
假设客户端有多个IP地址，那么如何确定哪一个IP地址与服务器端通信呢？方法是如果一个IP地址与服务器端IP地址位于同一网段, 那么就选择该IP地址.即同一子网优先，选择的IP地址应该尽量与服务器端IP地址处于同一网段中.
#### UNIX域协议
UNIX域协议的优点是在本机上的多个进程传递数据时，其数据传输速度是TCP连接的一倍

### 孤儿进程，僵尸进程和守护进程
孤儿进程指的是父进程在使用fork创建子进程后，父进程首先退出，这时子进程就没有父进程，称为孤儿进程，这时该子进程就会被init进程收养（pid=1), 由init负责对他们完成状态收集工作.

僵尸进程
僵尸进程指的是在子进程退出后，向父进程发送一个SIGCHLD信号，然后父进程没有使用wait或者waitpid函数完成对于子进程状态的收集。

守护进程
守护进程是运行在后台的一种特殊进程，他的父进程是init进程，因此，一般随着操作系统的启动而启动，随着操作系统的关闭而关闭.它没有对应的控制终端，一直运行在后台.

作用：一般用来实现服务器
特点：
独立于终端，关闭终端，相应的进程都会被关闭，而守护进程则不会关闭.
守护进程一般都运行在root模式下，因为它要使用某些特殊的端口
如何创建一个守护进程
1. 首先使用fork创建一个子进程，然后使用exit系统调用退出父进程， 目的有两个，一是让子进程变为孤儿进程，从而被init进程收养，第二点是确保子进程不是一个进程组的组长，因为一个进程组的组长不能成为session leader(若该进程组里的进程仍然存在于进程组中，那么这将导致同一个进程组的进程处于不同的会话中，这显然是不被允许的)），也就是会话首进程
2. 使用setsid函数创建一个会话
3. 在子进程中调用chdir函数，替换该进程的pwd为根目录
4. 在进程中关闭任何不需要的文件描述符
5. 在子进程中调用umask函数，设置umask值为0(不屏蔽任何的权限位），用户创建的文件的权限直接等于read时的mode值.


### 进程间通信方式:signal,file,pipe,shm, msg, socket

### 线程同步方式: 互斥量、锁机制、条件变量、信号量、读写锁

### fork返回值

### 五大I/O模型： 阻塞I/O, 非阻塞I/O， I/O复用，信号驱动I/O, 异步I/O
####阻塞I/O
直到满足特定条件时，才从阻塞I/O函数中返回，对于read来说，特定条件是套接字缓冲区内有数据足够数据可以读，对于write来说，特定条件下套接字缓冲区内有足够的空间可以写。

####非阻塞I/O
非阻塞I/O指的是即使没有满足特定的条件,也不会阻塞，而是返回一个错误。我们可以fcntl函数将socket套接字设置为非阻塞模式.如果该错误等于EAGAIN, EINTR或者EWOULDBLOCK,表示套接字缓冲区内的数据已经被读完.
非阻塞I/O不常用，原因是非阻塞I/O会一直运行，直到有数据到来，因此，非阻塞I/O是一种忙等待，非常浪费CPU.

#### I/O复用
主要使用select函数来实现，使用select函数来管理多个文件描述符, 一旦其中的一个文件描述符或者多个文件描述符满足了条件，select函数就返回, 这个时候就可以使用recv等函数处理对应的文件描述符，实际上这里是把阻塞的位置改变到了select位置

#### 信号驱动I/O
建立一个SIGIO的信号处理函数，即通过signal函数或者sigaction函数来安装SIGIO的信号处理函数,程序就可以用来处理其他事务，当数据到来时，就以信号形式通知给程序，我们就可以在信号处理函数中调用recv等函数，此时recv等函数也不会阻塞。
#### 异步I/O
效率最高
使用aio\_read函数来实现,这个函数提供一个请求,并提供一个缓存区，即使不满足特定条件,该函数也不会阻塞, 而是可以执行其他的任务.当数据到来时，内核就会自动将数据从内核空间即内核缓冲区拷贝到内存空间，然后以信号的形式发送给程序, 然后应用程序处理该数据.

这种模型与信号驱动I/O的区别在于, 异步I/O在得到信号之后，数据已经被放置在用户空间, 这时用户可以直接使用这些数据, 用户程序没有必要使用recv从套接字缓冲区读取数据，因而效率最高。

这种模型之所以没有被广泛使用，是因为aio\_read函数的实现总是有些问题.

以上五种I/O模型，除了异步I/O模型，其余都可以称为同步I/O, 因为在其余四种I/O模型中，使用read或者write函数都需要经过一定时间的等待，如信号驱动I/O和I/O复用在接收到I/O条件满足时，都需要将数据从内核中的套接字空间复制到用户空间, 这个过程可能比较漫长，比如读取的数据很多，那么这时候，可能会引发调度器线程先调度到其他的进程上进行工作，当数据拷贝完成后，再通过中断的方式通知当前CPU，然后再调度回去，然后read函数返回，因此，这里的read函数也是同步的.

### I/O复用机制
当服务器端异常终止时，会发送一个FIN报文段给客户端，这时客户端可能会处于等待用户输入的状态，那么这时直到用户输入字符，否则客户端是接受不到FIN报文段的。
因此，我们需要提供一种机制，使得内核一旦发现进程指定的一个或者多个I/O条件满足时，它就通知进程。这种能力就称为I/O复用.

### epoll和select, poll
有多种方式能够实现I/O复用，如select函数，epoll和poll函数
select函数实现的并发服务器，受到两个方面的限制
1. 一个进程所能打开的文件描述符数量, 可以通过ulimit -n来设置
2. select中的fd\_set中的集合的容量限制(FD\_SETSIZE),要更改只能重新编译内核.
因此，select能够实现的并发服务器所能连接的客户端的数目等于1024-3-1(3代表0，1，2， 1代表监听套接字），而客户端所能建立的最多的通信套接字个数为(1024-3).

而poll只受一个条件限制，一个进程所能打开的文件描述符数量

poll和select的缺点在于内核需要遍历所有的文件描述符，直到找到所有满足条件的文件描述符。而epoll解决了这个问题，epoll不会因文件描述符数目增加，而造成效率降低，是因为
select和poll都是基于轮询的方式实现的，select的轮询目标是第一个参数maxfd, poll的轮询目标是第二个参数nfds.而poll的实现是基于回调的，如果fd中有期望的事件发生，就通过回调函数将fd加入epoll就绪队列，因此，它只关心活跃的fd,与文件描述符最大可能值无关.

### LT水平触发和ET边缘触发
LT水平出发和ET边缘触发是epoll的两种触发方式
ET边缘触发指的epoll之关心由空闲变为就绪状态的文件描述符,而水平触发指的是只要事件没有处理完，就会触发，因而epoll就绪队列中一直有该文件描述符。因此，相对于LT水平触发，ET边缘触发，触发次数少，效率更高，但也容易出现问题.比如，容易丢失数据。
由于边缘触发方式只关心由空闲转为就绪状态的文件描述符，那么比如说读取一个文件描述符，当数据到来时，该文件描述符变为就绪状态，如果应用程序没有及时读取这些数据，那么该文件描述符一直处于就绪状态，epoll可能就会将该文件描述符从队列中删除，因此，可能会发生数据丢失状态

也就是说，对于水平触发模式，只要文件描述符上有数据可以读，那么就会一直通知epoll\_wait函数，直到把文件描述符上的数据读完，而对于边缘触发模式，即使没有读完所有的数据，也指挥通知epoll\_wait函数一次，直到有新的数据到来.
select和Poll都是水平触发模式，信号驱动I/O是边缘触发模式，epoll既支持水平触发，也支持边缘触发.
epoll的边缘触发模式必须要搭配非阻塞I/O来使用.
另外，一般的I/O复用都需要搭配非阻塞I/O来使用：
原因在于，select函数会检测套接字缓冲区，当有新数据到来分节到来，这时select会报告该文件描述符可读，但是由于传输过程中发生了错误，比如校验和检验出错，这时tcp协议仍然可能将这个数据包丢弃，这时如果使用阻塞I/O读取数据，就可能会阻塞于当前文件描述符，其余文件描述符的读取就必须推迟。

这是由于，select和read是两个独立的系统调用，二者之间有一定的窗口,select显示可读，read紧接着去读，并不能保证，一定可读.
一个典型的例子是超群现象，即多个线程使用select函数监听套接字，当有一个客户端链接到了服务器上，那么所有线程上的select函数都会显示监听套接字已经准备好，随时可以连接, 于是所有线程都会被唤醒，但最终只有一个进程accept了这个连接，其他的进程调用accept会被阻塞，这里就是select和read之间两个操作之间的窗口造成的.

epoll搭配非阻塞I/O，可以读取连接套接字，当read或者recv返回值为EINTR或者EAGAIN时，表明套接字缓冲区内的数据已经被读完，这时我们可以从while循环中break.因而继续处理下一个连接套接字.
因此，epoll搭配阻塞I/O, 有可能会造成进程一直阻塞，影响数据传输的效率.

### 关于同步或异步
同步指的是一个进程在执行某个系统调用时，如果该系统调用需要一定时间才能返回信息，那么该进程就一直等待，直到受到返回信息才继续执行
异步指的是如果该系统调用需要一定时间才能返回信息，那么该系统调用不会等待，而是继续执行下面的操作。当该系统调用完成时，才会以中断的方式通知给该进程，然后通知其进程处理.
### reactor和proacter模式

### 反向代理，负载均衡
